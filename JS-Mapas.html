<script>
  /**
   * ====================================================================
   * ARQUIVO: JS-Mapas.html
   * DESCRIÇÃO: Lógica do Leaflet, renderização de mapas, layers,
   * manipulação de polígonos (Turf.js) e eventos de mapa.
   * ====================================================================
   */

  window.isSelectionMode = false;
  window.selectedQuadras = [];
  
  // Controles de Visualização
  let modoRotuloAtual = 'id';
  let showTerritoryNumbers = true;  // Checkbox "Nomes"
  let showOptionalLabels = false;   // Checkbox "Opcionais" (Padrão: Oculto)
  
  // Grupos de Layers do Leaflet
  let layerGroupQuadras, layerGroupTerritorios, layerGroupTerritoryLabels, layerGroupVerticesTemp;
  let verticesSelecionados = [];

  // --- MAPA GERAL (HEATMAP/PONTOS) ---
  function carregarMapaGeral() {
    google.script.run.withSuccessHandler(dados => {
      document.getElementById('totalQuadrasGeral').innerText = dados.length;
      document.getElementById('totalDomiciliosGeral').innerText = dados.reduce((acc, c) => acc + c.total, 0);
      
      if(!mapGeral) { 
        mapGeral = L.map('mapGeral').setView([-7.115, -34.863], 13); 
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapGeral); 
      }
      
      dados.forEach(q => { 
        if(q.lat && q.lng) { 
          L.marker([q.lat, q.lng]).addTo(mapGeral)
           .bindPopup(`<div class="popup-quadra"><h6>${q.id}</h6><p>${q.total} Domicílios</p><button class="btn btn-sm btn-primary btn-ver-quadra" onclick="irParaDetalhes('${q.id}')">Ver</button></div>`); 
        } 
      });
      showLoading(false);
    }).getVisaoGeral();
  }

  // --- MAPA EDITOR (PRINCIPAL) ---
  function iniciarMapaPoligonos() {
    if (!mapPoligonos) {
      mapPoligonos = L.map('mapPoligonos').setView([-7.115, -34.863], 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapPoligonos);
      mapPoligonos.pm.setGlobalOptions({ allowSelfIntersection: false });
      
      // Inicializa Grupos
      layerGroupQuadras = L.featureGroup().addTo(mapPoligonos);
      layerGroupTerritorios = L.featureGroup().addTo(mapPoligonos);
      layerGroupTerritoryLabels = L.featureGroup().addTo(mapPoligonos);
      layerGroupVerticesTemp = L.featureGroup().addTo(mapPoligonos);
    }

    showLoading(true, "Carregando Malha...");
    
    // Limpa Layers Antigos
    layerGroupQuadras.clearLayers(); 
    layerGroupTerritorios.clearLayers(); 
    layerGroupTerritoryLabels.clearLayers(); 
    layerGroupVerticesTemp.clearLayers();
    
    limparSelecao();
    verticesSelecionados = [];

    // Carrega Polígonos de Quadras
    google.script.run.withSuccessHandler(dados => {
      if(dados && dados.length > 0) {
        dados.forEach(d => {
          if (d.polyString && d.polyString.length > 5) {
            const latlngs = d.polyString.split(" | ").map(par => { const c = par.split(","); return [parseFloat(c[0]), parseFloat(c[1])]; });
            const poly = L.polygon(latlngs, { color: d.color, fillColor: d.color, fillOpacity: 0.3, weight: 1, color: '#666' });
            poly.metaData = { ...d };
            poly.on('click', function(e) { if (window.isSelectionMode) toggleSelecaoQuadra(this); else abrirModalEdicao(this); });
            atualizarTextoTooltip(poly, modoRotuloAtual);
            layerGroupQuadras.addLayer(poly);
          }
        });
      }
      // Após carregar quadras, carrega territórios
      carregarTerritoriosSalvos();
    }).getPoligonosQuadras();
  }

  function carregarTerritoriosSalvos() {
    google.script.run.withSuccessHandler(dados => {
      if (dados) dados.forEach(t => {
           if (t.polyString && t.polyString.length > 5) {
             const latlngs = t.polyString.split(" | ").map(par => { const c = par.split(","); return [parseFloat(c[0]), parseFloat(c[1])]; });
             const poly = L.polygon(latlngs, { color: t.color, weight: 2, fillColor: t.color, fillOpacity: 0.5 });
             
             poly.metaData = { 
               name: t.name, 
               color: t.color, 
               quadras: t.quadras, 
               polyString: t.polyString,
               labelPos: t.labelPos,
               labelType: t.labelType || "visible" // Leitura do tipo
             };

             poly.on('click', function() {
               if (window.isSelectionMode) return;
               abrirModalEditarTerritorio(this.metaData);
             });

             layerGroupTerritorios.addLayer(poly);
             
             // Define Centro (ou posição customizada)
             let centro;
             if (t.labelPos && t.labelPos.includes(",")) {
               const parts = t.labelPos.split(",");
               centro = [parseFloat(parts[0]), parseFloat(parts[1])];
             } else {
               centro = poly.getBounds().getCenter();
             }

             // Cria Marcador de Rótulo
             const nomeFormatado = formatarTextoBadge(t.name);
             const myIcon = L.divIcon({ className: 'custom-badge-wrapper', html: `<div class="territory-badge">${nomeFormatado}</div>`, iconSize: [0, 0], iconAnchor: [0, 0] });
             
             const labelMarker = L.marker(centro, { icon: myIcon, interactive: true, draggable: false });
             
             // Guarda metadados no marcador para filtrar depois
             labelMarker.metaData = { 
               territoryName: t.name, 
               labelType: t.labelType || "visible"
             };
             
             layerGroupTerritoryLabels.addLayer(labelMarker);
           }
      });
      
      // APLICA FILTROS VISUAIS INICIAIS
      atualizarVisibilidadeLabels();

      // Ajusta visualização conforme dropdown (Quadras/Territórios)
      mudarVisualizacao(document.querySelector('select[onchange="mudarVisualizacao(this.value)"]').value);
      
      showLoading(false);
    }).getDadosTerritorios();
  }

  // --- FILTROS DE VISIBILIDADE DE RÓTULOS ---

  function toggleNumerosTerritorios(ativo) {
    showTerritoryNumbers = ativo; // Checkbox "Nomes"
    atualizarVisibilidadeLabels();
  }

  function toggleOptionalLabels(ativo) {
    showOptionalLabels = ativo; // Checkbox "Opcionais"
    atualizarVisibilidadeLabels();
  }

  /**
   * Função central que decide quais rótulos aparecem.
   * Regra:
   * 1. Se "Nomes" (Master) estiver OFF -> Oculta Tudo.
   * 2. Se "Nomes" estiver ON:
   * - Visible: Aparece.
   * - Optional: Aparece SÓ SE "Opcionais" estiver ON.
   */
  function atualizarVisibilidadeLabels() {
    if (!mapPoligonos) return;

    layerGroupTerritoryLabels.eachLayer(layer => {
      const tipo = layer.metaData.labelType;
      let deveAparecer = false;

      if (showTerritoryNumbers) {
        if (tipo === 'visible') {
          deveAparecer = true;
        } else if (tipo === 'optional' && showOptionalLabels) {
          deveAparecer = true;
        }
      }

      if (deveAparecer) {
        if (!mapPoligonos.hasLayer(layer)) layer.addTo(mapPoligonos);
        layer.setOpacity(1);
        if(layer._icon) layer._icon.style.display = 'block';
      } else {
        if (mapPoligonos.hasLayer(layer)) layer.remove();
      }
    });
    
    // Fallback: Adiciona ao grupo se não estiver
    if (showTerritoryNumbers) {
       layerGroupTerritoryLabels.eachLayer(layer => {
          const tipo = layer.metaData.labelType;
          if (tipo === 'visible' || (tipo === 'optional' && showOptionalLabels)) {
             if(!mapPoligonos.hasLayer(layer)) layer.addTo(mapPoligonos);
          }
       });
    }
  }

  // --- LÓGICA DE DRAG & DROP DO RÓTULO ---
  
  function setLabelDraggable(territoryName, enable) {
    layerGroupTerritoryLabels.eachLayer(layer => {
      if (layer.metaData && layer.metaData.territoryName === territoryName) {
        if (enable) {
          if (!mapPoligonos.hasLayer(layer)) layer.addTo(mapPoligonos); 
          layer.dragging.enable();
          if(layer._icon) layer._icon.style.cursor = "move";
        } else {
          layer.dragging.disable();
          if(layer._icon) layer._icon.style.cursor = "default";
        }
      }
    });
  }

  function getLabelPosition(territoryName) {
    let pos = null;
    layerGroupTerritoryLabels.eachLayer(layer => {
      if (layer.metaData && layer.metaData.territoryName === territoryName) {
        const ll = layer.getLatLng();
        pos = `${ll.lat},${ll.lng}`;
      }
    });
    return pos;
  }

  // --- AUXILIARES ---
  function selecionarQuadrasPorIds(listaIds) {
    if (!listaIds || listaIds.length === 0) return;
    layerGroupQuadras.eachLayer(layer => {
      if (listaIds.includes(layer.metaData.id)) {
        if (!window.selectedQuadras.find(q => q.id === layer.metaData.id)) {
           window.selectedQuadras.push({ id: layer.metaData.id, layer: layer });
           layer.setStyle({ color: 'red', weight: 4, dashArray: '10,5' });
        }
      }
    });
    if(typeof atualizarBotoesSelecao === 'function') atualizarBotoesSelecao();
  }

  function getDadosTerritorioPorNome(nome) {
    let encontrado = null;
    layerGroupTerritorios.eachLayer(layer => {
      if (layer.metaData && layer.metaData.name === nome) {
        encontrado = layer.metaData;
      }
    });
    return encontrado;
  }

  // --- GEOMETRIA: UNIÃO DE LISTA (Para Vítimas) ---
  function calcularUniaoDeListaIds(listaIds) {
    if (!listaIds || listaIds.length === 0) return "";
    const features = [];
    layerGroupQuadras.eachLayer(layer => {
      if (listaIds.includes(layer.metaData.id)) {
        features.push(layer.toGeoJSON());
      }
    });
    if (features.length === 0) return "";
    let unionPoly = features[0];
    for (let i = 1; i < features.length; i++) { 
      try { unionPoly = turf.union(unionPoly, features[i]); } catch(e) { console.warn(e); } 
    }
    if(!unionPoly || !unionPoly.geometry) return "";
    const coords = unionPoly.geometry.type === "Polygon" ? unionPoly.geometry.coordinates[0] : unionPoly.geometry.coordinates[0][0];
    return coords.map(c => `${c[1]},${c[0]}`).join(" | ");
  }

  function formatarTextoBadge(texto) {
    if (!texto) return ""; 
    let str = texto.toString(); 
    const palavras = str.split(" "); 
    if (palavras.length === 1) return str;
    
    // Quebra linha se a palavra tiver mais de 2 caracteres
    let novoTexto = palavras[0]; 
    for (let i = 1; i < palavras.length; i++) { 
      if (palavras[i].length > 2) novoTexto += "<br>" + palavras[i]; 
      else novoTexto += " " + palavras[i]; 
    } 
    return novoTexto;
  }

  // --- SELEÇÃO ---
  function toggleSelecaoQuadra(layer) {
    const id = layer.metaData.id;
    const idx = window.selectedQuadras.findIndex(q => q.id === id);
    if (idx === -1) { 
      window.selectedQuadras.push({ id: id, layer: layer }); 
      layer.setStyle({ color: 'red', weight: 4, dashArray: '10,5' }); 
    } else { 
      window.selectedQuadras.splice(idx, 1); 
      layer.setStyle({ color: '#666', weight: 1, dashArray: null }); 
    }
    atualizarBotoesSelecao();
  }
  
  function limparSelecao() {
    window.selectedQuadras.forEach(item => { item.layer.setStyle({ color: '#666', weight: 1, dashArray: null }); });
    window.selectedQuadras = [];
    if(document.getElementById('countSelectedBadge')) atualizarBotoesSelecao();
  }

  // --- FUSÃO (Merge) ---
  function calcularUniaoQuadras() { 
    if(window.selectedQuadras.length === 0) return "";
    const geo = calcularUniaoQuadrasGeoJSON();
    if(!geo || !geo.geometry) return "";
    // Trata Polygon vs MultiPolygon
    const coords = geo.geometry.type === "Polygon" ? geo.geometry.coordinates[0] : geo.geometry.coordinates[0][0];
    return coords.map(c => `${c[1]},${c[0]}`).join(" | "); 
  }
  
  function calcularUniaoQuadrasGeoJSON() {
    if (window.selectedQuadras.length === 0) return null;
    const features = window.selectedQuadras.map(item => item.layer.toGeoJSON());
    let unionPoly = features[0];
    for (let i = 1; i < features.length; i++) { try { unionPoly = turf.union(unionPoly, features[i]); } catch(e) { console.warn(e); } }
    return unionPoly;
  }

  // --- DIVISÃO (Split) ---
  function ativarSelecaoVerticesDivisao(quadraLayer) {
    layerGroupVerticesTemp.clearLayers(); 
    verticesSelecionados = [];
    const latlngs = quadraLayer.getLatLngs()[0];
    
    latlngs.forEach((latlng, index) => {
      // Cria bolinha branca no vértice
      const marker = L.circleMarker(latlng, { color: '#3388ff', fillColor: '#fff', fillOpacity: 1, radius: 6, weight: 2 });
      
      marker.on('click', function(e) { 
        L.DomEvent.stopPropagation(e); 
        verticesSelecionados.push(latlng); 
        this.setStyle({ color: 'red', fillColor: 'red' }); 
        
        if (verticesSelecionados.length === 2) { 
          executarCortePorPontos(quadraLayer, verticesSelecionados); 
          layerGroupVerticesTemp.clearLayers(); 
        } 
      });
      layerGroupVerticesTemp.addLayer(marker);
    });
  }

  function executarCortePorPontos(polyLayer, pontos) {
    try {
      const polyGeoJSON = polyLayer.toGeoJSON(); 
      const p1 = [pontos[0].lng, pontos[0].lat]; 
      const p2 = [pontos[1].lng, pontos[1].lat];
      const lineString = turf.lineString([p1, p2]); 
      const faca = turf.buffer(lineString, 0.0001, { units: 'kilometers' });
      
      const resultado = turf.difference(polyGeoJSON, faca); 
      if (!resultado) { alert("Falha no corte."); return; }
      
      let novasPartes = []; 
      if (resultado.geometry.type === 'MultiPolygon') { 
        resultado.geometry.coordinates.forEach(coords => { novasPartes.push(turf.polygon(coords)); }); 
      } else if (resultado.geometry.type === 'Polygon') { 
        alert("O corte não dividiu a área. Tente escolher vértices opostos."); 
        iniciarMapaPoligonos(); 
        return; 
      }
      receberCorteRealizado(novasPartes);
    } catch(e) { console.error(e); alert("Erro: " + e.message); iniciarMapaPoligonos(); }
  }

  // --- VISUALIZAÇÃO ---
  function mudarVisualizacao(modo) {
    if (!mapPoligonos) return;
    if (mapPoligonos.hasLayer(layerGroupQuadras)) layerGroupQuadras.remove();
    if (mapPoligonos.hasLayer(layerGroupTerritorios)) layerGroupTerritorios.remove();
    
    if (modo === 'quadras') { layerGroupQuadras.addTo(mapPoligonos); }
    else if (modo === 'territorios') { layerGroupTerritorios.addTo(mapPoligonos); }
    else { layerGroupTerritorios.addTo(mapPoligonos); layerGroupQuadras.addTo(mapPoligonos); }
  }
  
  function mudarRotulos(modo) {
    modoRotuloAtual = modo; 
    if(mapPoligonos) { 
      mapPoligonos.eachLayer(layer => { 
        if (layer instanceof L.Polygon && layer.metaData) atualizarTextoTooltip(layer, modo); 
      }); 
    }
  }
  
  function atualizarTextoTooltip(poly, modo) {
    let texto = ""; 
    const dados = poly.metaData;
    if (modo === 'id') texto = dados.id; 
    else if (modo === 'territory') texto = dados.territory; 
    else if (modo === 'both') texto = `${dados.id}\n${dados.territory}`;
    
    if (modo !== 'none' && texto) {
      poly.bindTooltip(texto, { permanent: true, direction: "center", className: "label-quadra" }).openTooltip(); 
    } else {
      poly.unbindTooltip();
    }
  }
  
  // --- DETALHES ---
  function atualizarMapaDetalhes(grupos) {
    if(!mapDetalhe) { 
      mapDetalhe=L.map('mapDetalhe'); 
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapDetalhe); 
    }
    mapDetalhe.eachLayer((layer) => { if(layer instanceof L.Marker) mapDetalhe.removeLayer(layer); });
    
    const bounds = []; 
    Object.values(grupos).forEach(g => { 
      if(g.lat && g.lng) { 
        L.marker([g.lat, g.lng]).addTo(mapDetalhe).bindPopup(`<b>${g.numero}</b> ${g.logradouro}`); 
        bounds.push([g.lat, g.lng]); 
      } 
    });
    
    if(bounds.length > 0) mapDetalhe.fitBounds(bounds, {padding:[30,30]}); 
    setTimeout(() => mapDetalhe.invalidateSize(), 300);
  }
</script>